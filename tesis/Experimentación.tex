\chapter{Experimentación}
En este capítulo se experimentará tomando una serie de problemas, ver \cite{BolibTestProblems}, 
que sean: Lineales, Cuadráticos y No Convexos. En ella primeramente utilizaremos las bibliotecas de Julia
para obtener puntos que sean mínimos locales, despues añadir valores aleatorios a esos puntos y posteriormente 
generar problemas estaciorarios del tipo: Fuertemente, M y C . Posteriormente estos problemas modificados serán nuevamente
ejecutados por los algoritmos tradicionales de Julia para conocer su efectividad con respecto al valor de la función objetivo del nivel superior.


Para ello tomaremos 15 problemas de optimización binivel SLSF, estos serán problemas 
Lineales, Cuadráticos y No Convexos, dividios en 5 problemas por cada clasificación anterior.
Estos han sido extraidos de \cite{Floudas1999HandbookOT} para las dos primeras clasificaciones y \cite{BolibTestProblems} para la última.

\newpage
\section{Problemas Escogidos}
Se muestran los problemas escogidos para la experimentación.

%Tabla con los problemas escogidos
\begin{table}[h!]
\centering
\caption{Problemas Seleccionados}
\begin{tabular}{ | m{5cm} | m{5cm} | m{5cm} | }
  
  \hline
  \textbf{No Convexos} & \textbf{Lineales} & \textbf{Cuadráticos} \\
  \hline
  MitsosBarton2006Ex312 & ex9.1.1 & ex9.2.1 \\
  \hline
  MitsosBarton2006Ex313 & ex9.1.2 & ex9.2.2 \\
  \hline
  MitsosBarton2006Ex314 & ex9.1.8 & ex9.2.3\\
  \hline
  MitsosBarton2006Ex323 & ex9.1.9 & ex9.2.4\\
  \hline
  MorganPatrone2006a & ex9.1.10 & ex9.2.5 \\
  \hline
\end{tabular}
\end{table}



\newpage
\section{Modelación de la experimentación}
Se describirá el proceso de generar la experimentación. 
Todos los valores han sido redondeados por exceso a dos cifras después de la coma. 

\subsubsection{Obtención de los óptimos}
Inicialmente se necesita obtener óptimos de los problemas con los paquetes convencionales de Julia
cuyos pasos son los siguientes:
\begin{itemize}
    \item \textbf{Problemas Lineales y Cuadráticos :}\\
            Con dicho problema se introduce los datos en la interfaz de \textbf{BilevelJuMP}, ver \cite{BilevelJump}, con el cual se utilizan
            Con ellas utilizamos 3 técnicas entre las ofrecidas por esta:
            \begin{itemize}
                \item \textbf{Big-M :} Con el optimizador High-Performance Solver for Linear Programming (HiGHS) y los valores $\text{primal big M} = 100, \quad \text{dual big M} = 100$.
                \item \textbf{SOS1 :} Con el optimizador Solving Constraint Integer Programs (SCIP).
                \item \textbf{ProductMode :} Con el optimizador Interior Point Optimizer (Ipopt).
            \end{itemize} 
            Cada uno de los resultados de evaluar el problema en cada forma anterior se guarda en un formato \textit{.xlsx}
            donde por cada optimizador se guarda los parámetros:
            \begin{itemize}
                \item Estatus del Primal, el cual define si es un punto factible o no.
                \item Estatus de la Finalización, si terminó porque encontro un óptimo o se estancó en un óptimo local.
                \item Valor de la función objetivo del nivel superior.
                \item El punto óptimo encontrado, en caso de ser hallado.
            \end{itemize} 
            Posteriormente se analizan los resultados de dichos métodos, se selecciona el de mejor evaluación de la función objetivo.
    \item \textbf{Problemas No Convexos :}\\
            Con dicho problema al \textbf{BilevelJuMP} no contar con soporte para esta clase de problemas binivel se utiliza \textbf{JuMP}, ver \cite{JuMPPaper}, 
            por ello se utiliza la reformulación KKT como la de \refeq{eq:KKT_Optimista} y se procede a utilizar la interfaz brindada por este, para el caso de las restricciones de 
            complementariedad se utiliza \textbf{Complementarity}, ver \cite{Complementarityjl}, con el optimizador Ipopt y análogo al caso anterior se extraen los mismos datos.
\end{itemize}


\subsubsection{Generación de los problemas}
% Como se modifica el punto
Se toma el problema original de entrada y el punto obtenido en el paso anterior el cual en cada componente se le hace suma un
valor aleatorio entre $1e-10$ y $5$, siendo este modificado: $z^*_0$. 
% Que se generan 3 clases de problemas estacionarios
Y se generan los 3 problemas bajo los 3 tipos de estacionariedad descritos en cada uno, 
% Se toma \alpha=0 y \alpha!=0
además en cada uno se toma la opcion de $\vec{\alpha}=\vec{0}$ y $\vec{\alpha}\ne \vec{0}$.
Para los $\vec{\alpha}=\vec{0}$ se genera un vector aleatorio donde cada componente está entre $1e-10$ y $3$.
% Como se dividen los indices activos
Luego para los conjuntos de índices activos de las $v_{j}s$ se dividen en $1/2$ del tipo $J_1^v$ \refeq{J_0_lambda_0_level_inferior} y $1/4$ para los dos restantes.
% Explicar como se modifican los indices activos 
Con respecto a la selección de los multiplicadores $\beta_j$ y $\gamma_j$ se 
se generan valores aleatorios entre $1e-10$ y $10$ en caso que estos no tengan que ser $0$, 
para los casos en que haya más de una combinación de los multiplicadores con respecto a su igualdad a $0$
se toma un valor aleatorio generado por una distribución uniforme discreta.
% Como se guarda
Finalmente cada problema generado es guardado en un archivo \textit{xlsx} con la siguiente designación:
\textit{(nombre del problema)\_(Tipo de punto estacionario)(generator)\_alpha\_((non\_zero) si $\alpha \neq 0$ y (zero) si $\alpha = 0$).xlsx}.
Donde se guarda: 
\begin{itemize}
    \item Las expresiones de las funciones objetivo de ambos niveles y su valor evaluado en el punto.
    \item Las restricciones de ambos niveles con sus multiplicadores respectivos, el tipo de indice activo y la evaluación de dicha función en el punto.
    \item El punto $z^*_0$.
    \item El $\vec{bf}.$
    \item El $\vec{BF}$.
    \item El $\vec{\alpha}$.
\end{itemize}

\subsubsection{Comparación de los algoritmos de Julia}
Después de tener generados los problemas se utilizan los mismos métodos de Julia mencionados anteiormente
para obtener óptimos de cada problema generado y se elige como representante el que más haya superado su óptimo o en caso de no superar el que mayor distancia tenga con el valor objetivo inicial.

\subsection{Resultados:}
Se presentan los resultados seleccionados bajo los criterios expuestos anteriormente en las siguientes tablas que contienen:
% Explicacion de las tablas
\begin{itemize}
    \item El nombre del problema original desde el cual fue modificado para que fuese estacionario de la clase deseada. 
    \item El punto al cual se forzó ser estacionario de la clase requerida.
    \item La evaluación de la función objetivo del punto estacionario.
    \item El punto óptimo hallado por los algoritmos de Julia.
    \item La evaluación de la función objetivo del óptimo.
    \item Método seleccionado.
\end{itemize}

\subsubsection{Para $\alpha =0$} 
% Tabla con los problemas lineales escogidos
%- Lineales
%	- C-Estacionario: ex9.1.1
%	- Fuertemente: ex9.1.10
%	- M-Estacionario:ex9.1.8
%	- Alpha=0: ex9.1.8
\begin{resultstable}{Problemas Seleccionados para $alpha=0$}
    \resultrow{ex9.1.8}{}{}{}{}{}
    \resultrow{ex9.2.3}{(1.55,2.7,-5.1,-8.65)}{-10.25}{(0,0,-5.1,-10)}{-14.7}{Big-M}
    \resultrow{MitsosBarton2006Ex313}{}{}{}{}{}
    \end{resultstable}






